<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSCF+: 4.3 Build System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSCF+
   &#160;<span id="projectnumber">v1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">PSCF+:  Polymer Self-Consistent Field Theory (C++/CUDA) with Improved and Extended Capabilities</a></li>  </ul>
</div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">4.3 Build System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="code_format_page.html">4.2 Coding Standards</a> (Prev) &#160; &#160; &#160; &#160; <br  />
</p>
<p>PSCF+ is compiled using a system of unix makefiles. All development was done using gnu make (gmake).</p>
<h1><a class="anchor" id="make_blddir"></a>
Build directories</h1>
<p>When source files from the src/ directory are compiled, the resulting object (*.o) files and other files generated by compilation are placed in a directory that we refer to as the build directory. The PSCF makefile system can implement either an "out-of-source" build, in which the build directory tree is distinct from the src/ directory, or an "in-source-build", in which all generated files are placed in the src/ directory alongside the source files. The pscfpp/bld/ directory is used as the build directory for out-of-source compilation.</p>
<p>The choice between in-source and out-of-source builds is determined by where one invokes the "make" command: Invoking "make" from within the src/ directory causes the code to be built in source, while invoking "make" from the pscfpp/bld directory causes the code to be built out-of-source in pscfpp/bld.</p>
<p>Compiling a source file normally creates an object file and a dependency file with the same base name as the source file but with file name extension *.o and *.d, respectively. Each dependency file contains a makefile target rule that lists all the files within the src/ directory tree upon which the associated *.o object file depends, including all the header files that it includes. The object and dependency fields are placed in the same subdirectory of the build directory tree.</p>
<h1><a class="anchor" id="make_configuration"></a>
Build configuration files</h1>
<p>After the setup script has been run, but before any code has been compiled, each of the two possible build directories (src/ and bld/) contain the following files and namespace level subdirectories: </p><div class="fragment"><div class="line">BLD_DIR/</div>
<div class="line">   makefile</div>
<div class="line">   config.mk</div>
<div class="line">   configure</div>
<div class="line">   util/</div>
<div class="line">   pscf/</div>
<div class="line">   fd1d/</div>
<div class="line">   pspc/</div>
<div class="line">   pspg/</div>
</div><!-- fragment --><p> Here, we use the BLD_DIR to represent the path to a specific build directory. The purposes of the files in this directory are:</p>
<ul>
<li>makefile is the main makefile for a particular build directory.</li>
<li>config.mk is the main build configuration file (makefile fragment)</li>
<li>configure is a bash script that can be used to enable or disable some features before compilation.</li>
</ul>
<p>After setup but before compilation, each of the five namespace level subdirectories (util/, pscf/, fd1d/, pscp/, and pspg/) of each build directory also contains a few makefile fragments with similar names, of the form: </p><div class="fragment"><div class="line"><span class="keyword">namespace</span>/</div>
<div class="line">   makefile</div>
<div class="line">   config.mk</div>
<div class="line">   tests/</div>
<div class="line">      makefile</div>
</div><!-- fragment --><p> Here, we use "namespace/" to denote a namespace level directory name, such as "util/" or "pspc/". The purposes of these files are:</p>
<ul>
<li>namespace/makefile is the main makefile for a single namespace.</li>
<li>namespace/config.mk file is a build configuration file for a single namespace.</li>
<li>namespace/tests/makefile is a makefile for unit tests for code in one namespace level directory.</li>
</ul>
<p>The makefile in each namespace level subdirectory contains an "all" target that compiles all of the source files in the corresponding namespace (or subdirectory), creates a static library that contains all of the resulting objects, and compiles and installs any main programs in that directory. After setup but before compilation, the bld/ directory is empty except for the files listed above. After setup, the src/ directory also contains copies of these files, in addition to source files and other makefile fragments.</p>
<p>The config.mk files in the root of each build directory tree (i.e., in src/ and bld/) and in its namespace level subdirectories will be referred to in what follows as build configuration files. Each such build configuration file file is a makefile fragment that is installed by the setup script by making copies of default versions stored in the directory make/config.</p>
<h2><a class="anchor" id="make_config_main"></a>
Main config.mk file</h2>
<p>The main config.mk in each build directory defines makefile variables that contain paths to the source, build and binary directories, and other variables that define the choice of compiler and various compiler options.</p>
<p>The following variables defined in the main config.mk file define paths:</p>
<ul>
<li>SRC_DIR contains the absolute path to the pscfpp/src/ directory.</li>
<li>BLD_DIR contains the absolute path to the build directory.</li>
<li>BIN_DIR contains the absolute path to the directory in which executables are installed.</li>
</ul>
<p>In the main config.mk in each build directory, BLD_DIR is given by the absolute path for that directory. By default, BIN_DIR is the absolute path to the pscfpp/bin directory. The values of the above three variables are expressed in terms of a variable ROOT_DIR that contains the absolute path to the pscfpp/ root directory. The correct value for ROOT_DIR is set by the setup script. Here is an example of the relevant part of the file bld/serial/config.mk: </p><div class="fragment"><div class="line">ROOT_DIR=${HOME}/pscfpp</div>
<div class="line">SRC_DIR=$(ROOT_DIR)/src</div>
<div class="line">BLD_DIR=$(ROOT_DIR)/bld</div>
<div class="line">BIN_DIR=$(ROOT_DIR)/bin</div>
</div><!-- fragment --><p> Here, for simplicity, we have assumed that the pscfpp/ root directory is a subdirectory of the users home directory. In the actual file, this would be replaced by the literal absolute path to whatever parent directory contains the pscfpp/ directory.</p>
<p>sub</p>
<h1><a class="anchor" id="make_config_namespace"></a>
Namespace level config.mk files</h1>
<p>The "config.mk" file in each of the namespace level subdirectories of src/ and bld/ contains definitions of variables that are used in the pattern rules used to compile code in that directory.</p>
<h1><a class="anchor" id="make_namespace_makefile"></a>
Namespace directory makefiles</h1>
<p>The makefile in each namespace level subdirectory of each build directory defines an "all" target. The "all" target compiles all of the source files in the corresponding subdirectory of src/, or the corresponding namespace.</p>
<p>The "all" target in each namespace level directory also creates a static library that contains the object files for all classes in the associated namespace. The base name of each such library is given by a prefix "lib" followed by the namespace level directory name with a file extension ".a". Each such library is placed in the corresponding namespace level build directory. For example, the makefile in the util/ subdirectory creates a static library that (by default) is named BLD_DIR/util/libutil.a. Executable files are built by linking main program files to these namespace level libraries.</p>
<p>The "all" targets of the makefiles in the fd1d, pspc, and pspg namespace level subdirectories also compile main programs and install the resulting executables in the BIN_DIR directory. Entering "make all" from the BLD_DIR/fd1d directory compiles and links the main program src/fd1d/pscf_fd.cpp, in addition to compiling all of the required class files and aggregating the source files into a static library.</p>
<h1><a class="anchor" id="make_sources"></a>
Source file lists (sources.mk files)</h1>
<p>Every subdirectory of src/ (other than the tests/ directories) contains a makefile fragment named "sources.mk". Each such file defines a variable that contains a list of the source files in that directory and all of its subdirectories (if any). In each such subdirectory of src/, this variable has a name of the form [directory]_, where "[directory]" represents a mangled form of the subdirectory name. Specifically, the [directory] string is constructed by taking the path from the src/ directory to the subdirectory of interest and replacing each "/" directory separator by an underscore ("_"). For example, the file src/util/sources.mk defines a variable util_ that expands to a list of all of the source files in the directory tree rooted at src/util. The file src/util/space/sources.mk defines a corresponding variable named util_space_. The value of the [directory]_ variable is a list of relative paths for all source files in the corresponding directory and its descendant subdirectories, in which the path to each source file is expressed relative to the pscfpp/src/ directory.</p>
<p>The code that assigns a value to a [directory]_ source list variable is straightforward in directories that contain source files but no subdirectories, such as the util/space directory. For example, here is the definition of util_space_ from the file src/util/space/sources.mk: </p><div class="fragment"><div class="line">util_space_= \</div>
<div class="line">    util/space/Grid.cpp \
    util/space/IntVector.cpp \
    util/space/Tensor.cpp \
    util/space/Vector.cpp</div>
</div><!-- fragment --><p> The directory src/util/space contains four sources files named <a class="el" href="Grid_8cpp_source.html">Grid.cpp</a>, <a class="el" href="IntVector_8cpp_source.html">IntVector.cpp</a>, <a class="el" href="Vector_8cpp_source.html">Vector.cpp</a> and <a class="el" href="Tensor_8cpp_source.html">Tensor.cpp</a>, and has no subdirectories.</p>
<p>In source file directories that do contain subdirectories, however, the source file list is constructed by concatenating corresponding lists defined in the source.mk files of subdirectories. In this case, the "sources.mk" file in the parent directory must include the sources.mk files from all of subdirectories. The value of the [directory]_ variable for the parent directory is then constructed by concatenating values of the [subdirectory]_ variables, and then appending additional source files from the parent directory, if any. For example, here is the makefile code that defines the variable util_ in the file src/util/sources.mk: </p><div class="fragment"><div class="line"><span class="preprocessor"># Include subdirectory sources.mk files</span></div>
<div class="line">include $(SRC_DIR)/util/misc/sources.mk</div>
<div class="line">include $(SRC_DIR)/util/format/sources.mk</div>
<div class="line">include $(SRC_DIR)/util/containers/sources.mk</div>
<div class="line">include $(SRC_DIR)/util/mpi/sources.mk</div>
<div class="line">include $(SRC_DIR)/util/signal/sources.mk</div>
<div class="line">include $(SRC_DIR)/util/param/sources.mk</div>
<div class="line">include $(SRC_DIR)/util/math/sources.mk</div>
<div class="line">include $(SRC_DIR)/util/space/sources.mk</div>
<div class="line">include $(SRC_DIR)/util/random/sources.mk</div>
<div class="line">include $(SRC_DIR)/util/boundary/sources.mk</div>
<div class="line">include $(SRC_DIR)/util/crystal/sources.mk</div>
<div class="line">include $(SRC_DIR)/util/ensembles/sources.mk</div>
<div class="line">include $(SRC_DIR)/util/accumulators/sources.mk</div>
<div class="line">include $(SRC_DIR)/util/archives/sources.mk</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Concatenate subdirectory source file lists</span></div>
<div class="line">util_=$(util_misc_) $(util_format_) \</div>
<div class="line">    $(util_containers_) $(util_mpi_) \</div>
<div class="line">    $(util_signal_) $(util_param_) $(util_math_) \</div>
<div class="line">    $(util_space_) $(util_random_) $(util_boundary_) \</div>
<div class="line">    $(util_crystal_) $(util_ensembles_) \</div>
<div class="line">    $(util_accumulators_) $(util_archives_)</div>
</div><!-- fragment --><p> The first segment of the file is a set of include statements that include the sources.mk files from all subdirectories of src/util. The definition of util_ then simply concatenates the corresponding source file lists for all subdirectories.</p>
<p>The sources.mk file in each such subdirectory of src/ also defines two variables that expand into lists of absolute paths for all source files and all object file targets in that subdirectory and its subdirectories. These variables have names of the form [directory]_SRCS and [directory]_OBJS, respectively, where [directory] again represents the mangled directory name. Thus, for example, the file src/util/sources.mk defines variables named util_SRCS and util_OBJS, in addition to util_. The [directory]_SRCS and [directory]_OBJS variables are constructed by using the gmake "addprefix" function to add absolute paths for the source and build directories as prefixes to each relative path listed in the [directory]_ variable. The relevant lines in the file src/util/sources.mk look like this: </p><div class="fragment"><div class="line">util_SRCS=\</div>
<div class="line">     $(addprefix $(SRC_DIR)/, $(util_))</div>
<div class="line">util_OBJS=\</div>
<div class="line">     $(addprefix $(BLD_DIR)/, $(util_:.cpp=.o))</div>
</div><!-- fragment --><p> Here, SRC_DIR expands to the absolute path to the pscfpp/src directory and BLD_DIR expands to the absolute path to the relevant build directory. Note that the only difference between the paths in a [directory]_ variable (e.g., util_) and those in a [directory]_SRCS variable (e.g., util_SRCS) is that the [directory]_ variable contains relative paths, relative to src/, while the [directory]_SRCS variable contains corresponding absolute paths.</p>
<h1><a class="anchor" id="make_patterns"></a>
Pattern rules (patterns.mk files)</h1>
<p>Each namespace level subdirectory of the src/ directory has a makefile fragment named "patterns.mk". This file defines pattern rules for compiling source files in that directory or namespace. The pattern rule has the same structure in all five namespace level directories. In directories that contain C++ files, the main rule always looks like this: </p><div class="fragment"><div class="line">$(BLD_DIR)/%.o:$(SRC_DIR)/%.cpp</div>
<div class="line">        $(CXX) $(CPPFLAGS) $(CXXFLAGS) $(INCLUDES) $(DEFINES) -c -o $@ $&lt;</div>
<div class="line">ifdef MAKEDEP</div>
<div class="line">        $(MAKEDEP) $(INCLUDES) $(DEFINES) $(MAKE_DEPS) -S$(SRC_DIR) -B$(BLD_DIR) $&lt;</div>
<div class="line">endif</div>
</div><!-- fragment --><p> This target pattern creates a rule for creating an object file with file extension *.o in a subdirectory of the build directory BLD_DIR by compiling a *.cpp source file with the same base name in the corresponding subdirectory of the source directory SRC_DIR. The first command actually compiles the source file and creates the object file. The second command, which is within an ifdef MAKEDEP .. endif block, generates a dependency file with extension *.d as a side-effect of compilation.</p>
<p>The following variables used in the above pattern are defined in the main config.mk file file in the build directory from which make was invoked:</p>
<ul>
<li>BLD_DIR: Absolute path to the build directory</li>
<li>SRC_DIR: Absolute path to the pscfpp/src directory</li>
<li>CXX: name of the C++ compiler executable</li>
<li>CPPFLAGS: flags for the C preprocessor</li>
<li>CXXFLAGS: general flags for the C++ compiler (optimization, warnings, etc.)</li>
<li>INCLUDES: directories to search for C++ header files, using the -I compiler option</li>
<li>MAKEDEP: Name of the script used to generate dependency files (bin/makeDep by default)</li>
</ul>
<p>The same values are used for the above variables in all five namespaces. Two additional variables are defined within each patterns.mk file that are assigned different values in different namespaces. These are:</p>
<ul>
<li>DEFINES: String of all relevant C++ preprocessor macro definitions, defined using the compiler "-D" option</li>
<li>MAKE_DEPS: List of build configuration files that should be listed as dependencies for all object files in this namespace</li>
</ul>
<p>The DEFINES variable, if not empty, contains a series of preprocessor macro definitions, defined using the "-D" compiler option. Thus, for example, if debugging is enabled, the value of DEFINES within the file src/inter/patterns.mk might expand to </p><div class="fragment"><div class="line">DEFINES=-DUTIL_DEBUG</div>
</div><!-- fragment --><p> The definitions of DEFINES and MAKE_DEPS within the file src/pspc/patterns.mk are shown below as an example: </p><div class="fragment"><div class="line"><span class="preprocessor"># C preprocessor macro definitions</span></div>
<div class="line">DEFINES=$(UTIL_DEFS) $(PSPC_DEFS)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Dependencies of source files in src/pspc on makefile fragments</span></div>
<div class="line">MAKE_DEPS= -A$(BLD_DIR)/config.mk</div>
<div class="line">MAKE_DEPS+= -A$(BLD_DIR)/util/config.mk</div>
<div class="line">MAKE_DEPS+= -A$(BLD_DIR)/pspc/config.mk</div>
</div><!-- fragment --><p> The DEFINES variable is constructing by concatenating the NAMESPACE_DEFS variables (UTIL_DEFS, PSPC_DEFS, etc.) for this namespace (i.e., PSPC_DEFS) and for all namespaces upon which this namespace depends (i.e., UTIL_DEFS). For the Pscf::Pspc namespace, this yields a concatenation of UTIL_DEFS and PSPC_DEFS. The resulting string contains all of the preprocessor definitions that are allowed to be used by code in this namespace.</p>
<p>The MAKE_DEPS variable contains a list of build configuration files whose contents can effect compilation of source code in this namespace. This list always contains the main config.mk file from the parent build directory, the config.mk file for the namespace of interest, and config.mk files for any namespace(s) upon which this namespace depends. For the Pscf::Pspc namespace, MAKE_DEPS thus contains paths to the config.mk files in the pspc/ and util/ subdirectories. These build configuration files are added to the list of dependencies for every object file in this namespace because changes to these config.mk files can change which preprocessor macros are defined or which compiler options are set, and thus can change the contents of the resulting object files.</p>
<h1><a class="anchor" id="make_dependency"></a>
Dependency Files (*.d Files)</h1>
<p>If automatic dependency generation is not disabled, a dependency file will be generated for each source file whenever the file is compiled, as a side effect of compilation. Each dependency file defines a makefile rule for constructing the corresponding object file. This rule can be used to determine when the source file needs to be recompiled as a result of changes in header files or other files upon which it depends. The rule consists of the name of the object file target followed by a colon and list of files upon which it depends, of the form </p><div class="fragment"><div class="line"><span class="keyword">class</span>.o: <span class="keyword">class</span>.cpp <span class="keyword">class</span>.h header1.h header2.h ....</div>
</div><!-- fragment --><p> The list of dependencies for each object (*.o) file target includes the corresponding source (*.cpp) file, all of the header files that this source file directly or indirectly includes. The end of this list also includes all of the configuration files specified by the MAKE_DEPS variable for the relevant namespace. Each such makefile rule only lists dependencies, but does not contain an explicit command, because the required compiler command is given implicitly by the appropriate pattern rule.</p>
<p>Though not shown in the above example, all paths to the target and its dependencies are actually given in dependency files as absolute paths.</p>
<p>Dependency files are created by the bash script pscfpp/bin/makeDep. The pattern rules defined in the namespace level patterns.mk files apply the makeDep script to a source file whenever that file is compiled. The "makeDep" script works by calling the gnu g++ compiler with the -MM option to determine dependencies, and using a separate python script to edit the resulting file.</p>
<p>In each makefile at the namespace level and below, all relevant dependency files are included into the makefile by a command of the form </p><div class="fragment"><div class="line">-include $([directory]_OBJS:.o=.d)</div>
</div><!-- fragment --><p> in which [directory] represents the mangled name of the directory containing the makefile. For example, the file src/mcMd/makefile contains a line </p><div class="fragment"><div class="line">-include $(mcMd_OBJS:.o=.d)</div>
</div><!-- fragment --><p> This command attempts to include a *.d dependency file for each *.o object file in the object file list. The dash in front of "include" instructs "make" to continue quietly if no dependency file is found for any object file target.</p>
<h1><a class="anchor" id="make_makefile"></a>
Example: A Namespace Directory makefile</h1>
<p>As an example of how the system works, here are the essential parts of the namespace level makefile from the directory bld/serial/inter. The actual makefile also includes "clean" and "veryclean" targets that have been excluded for clarity. Corresponding makefiles in bld/parallel/inter and src/inter are identical:</p>
<div class="fragment"><div class="line">BLD_DIR_REL =..</div>
<div class="line">include $(BLD_DIR_REL)/config.mk</div>
<div class="line">include $(BLD_DIR)/util/config.mk</div>
<div class="line">include $(BLD_DIR)/inter/config.mk</div>
<div class="line">include $(SRC_DIR)/inter/patterns.mk</div>
<div class="line">include $(SRC_DIR)/inter/sources.mk</div>
<div class="line"> </div>
<div class="line">all: $(inter_OBJS) $(inter_LIB)</div>
<div class="line"> </div>
<div class="line">-include $(inter_OBJS:.o=.d)</div>
</div><!-- fragment --><p> This simplified makefile contains three blocks:</p>
<p>(1) The block of include statements at the top of this file include all of the relevant build configuration files, the appropriate patterns.mk file, and the appropriate source file lists. The main config.mk file must be included using a relative path BLD_DIR_REL_=.. to the parent build directory. The main config.mk file defines variables BLD_DIR and SRC_DIR that contain absolute paths to the object and source directories, which can be used in the remainder of this makefile, and in makefile fragments that it includes. Next, the makefile includes the namespace level config.mk files for this namespace and any namespaces that it depends on. In this example, it thus includes the inter/config.mk and util/config.mk files from the build directory, because the Pscf::Pspc namespace depends upon the <a class="el" href="namespaceUtil.html" title="Utility classes for scientific computation.">Util</a> namespace. Finally, the makefile includes the patterns.mk file and sources.mk file list from the associated namespace level source directory src/inter.</p>
<p>(2) The "all" target builds all of the object files in the Pscf::Pscf namespace, which are listed in the variable inter_OBJS, and builds the associated library, whose name given by the variable inter_LIB. The file inter/sources.mk defines both the object file list inter_OBJS and a target rule for building the library inter_LIB. The library name inter_LIB is defined in the namespace level configuration file inter/config.mk.</p>
<p>(3) The last line of the above makefile fragment instructs make to include all of the dependency files for all of the source files in this namespace. The syntax $(inter_OBJS:.o=.d) creates a list of vfiles in which the .o extension of each object file is replaced by a .d extension. The dash in front of the -include command tells make to continue quietly if any dependency file does not exist.</p>
<p>The first time "make all" is invoked in this directory, neither the object file nor the associated dependency files exist. In this case, since each object target file is absent, make knows that it must be built, and uses the pattern rule defined in inter/patterns.mk to create each object file listed in inter_OBJS. If "make all" is a called again from the same directory, however, make can use the information in the dependency files to determine which object files needs to be rebuilt as a result in changes in C++ or configuration files.</p>
<p>The target rule for library inter_LIB lists all of the object files in inter_OBJS as dependencies. The library will thus be built only after the object files are all built, and will automatically be rebuilt if any object file in the Pscf::Pspc namespace is rebuilt.</p>
<h1><a class="anchor" id="make_makefile_executable"></a>
Namespace Directory makefiles with Executable Targets</h1>
<p>The makefile for the inter/ namespace level directory, which we used above as an example, does not build any executable files. Corresponding makefiles for the mcMd/, ddMd/, and tools/ subdirectories of each build directory, however, also contain targets that that build executables. Each executable is built by linking an object file that is created by compiling a main program file to several namespace-level static libraries. For example, the mcSim and mdSim executables are created by compiling the main program source files src/mcMd/mcSim.cpp and src/mcMd/mdSim.cpp and then linking the resulting object files to static libraries from the mcMd/, inter/ and util/ build directories. The target rules for the final executables list the required static libraries as dependencies.</p>
<p>The fact that executable targets depend on libraries that are defined in other namespaces requires the following further changes to the structure of makefiles that contain executable targets:</p>
<ul>
<li>Each makefile with executable targets must include the sources.mk source file list from every namespace that contributes objects to the target executables.</li>
<li>Each such makefile must include all *.d dependency files from every namespace that contributes objects to the target executables.</li>
</ul>
<p>Thus, for example, the mcMd/makefile in each build directory must include the sources.mk files from the inter/ and util/ subdirectories of the src/ directory, and must include all dependency files from corresponding subdirectories of BLD_DIR, in addition to files from the mcMd/ subdirectory. Inclusion of these additional files from other namespace level directories allows make to decide when any required library needs to be rebuilt, and provides instructions how to rebuild any required source file or library if necessary.</p>
<h1><a class="anchor" id="make_subdirectory"></a>
Subdirectory Makefiles</h1>
<p>As a convenience for developers, every subdirectory src/ at the namespace level and below contains a makefile. The "all" target of each such src/ subdirectory makefile executes an in-source build of the files in that subdirectory and any descendant subdirectories. The structure of the makefiles in subdirectories of the namespace level directories is very similar to that of the namespace level makefiles, except for the absence of targets to build a library or executables.</p>
<p>During development, the most convenient way to test whether a source file that you have just modified compiles correctly is usually to just enter </p><div class="fragment"><div class="line">&gt; make all</div>
</div><!-- fragment --><p> from the directory that contains the new or newly modified source file. If automatic dependency generation is enabled, and if you only modify one class at a time, this will normally cause the build system to compile only the source file that you have just modified. If a directory contains more than one incomplete or broken file, you should temporarily comment out all but one of these files (the one you are working on) in the definition of the [directory]_ variable in the corresponding sources.mk file, and then uncomment each such file when you are ready to work on it.</p>
<p>The file name conventions used in the PSCF build system make it awkward for a user to explictly request compilation of a specific source file. The build system uses absolute paths for all source and object files. The "make" program is not smart enough to recognize when an absolute and relative path are equivalent. As a result, the only way explicitly request compilation of a specific source file is to use the absolute path to the object file as a makefile target. For example, if the absolute path to the root PSCF directory within a user account named "george" was "/home/george/pscfpp/", you (or George) could compile the source file src/mcMd/simulation/Simulation.cpp in-source by entering </p><div class="fragment"><div class="line">make /home/george/pscfpp/src/mcMd/simulation/Simulation.o</div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line">make ~/pscfpp/src/mcMd/simulation/Simulation.o</div>
</div><!-- fragment --><p> from either the src/mcMd/simulation or src/mcMd/ directory. Most programmers, however, are unwilling to repeatedly type absolute paths. This is why we recommend getting in the habit of simply using "make all" from the directory that contains the file of interest, and working on only one file at a time.</p>
<p><br  />
 <a class="el" href="code_format_page.html">4.2 Coding Standards</a> (Prev) &#160; &#160; &#160; &#160; <a class="el" href="index.html">Main Page</a> (Up) &#160; &#160; &#160; &#160; </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 5 2024 11:30:07 for PSCF+ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
