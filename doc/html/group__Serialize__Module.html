<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSCF+: Serialization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSCF+
   &#160;<span id="projectnumber">v1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Serialization<div class="ingroups"><a class="el" href="group__Util__NS__Module.html">Util namespace</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1BinaryFileIArchive.html">Util::BinaryFileIArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving archive for binary istream.  <a href="classUtil_1_1BinaryFileIArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1BinaryFileOArchive.html">Util::BinaryFileOArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving / output archive for binary ostream.  <a href="classUtil_1_1BinaryFileOArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1MemoryIArchive.html">Util::MemoryIArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input archive for packed heterogeneous binary data.  <a href="classUtil_1_1MemoryIArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1MemoryOArchive.html">Util::MemoryOArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save archive for packed heterogeneous binary data.  <a href="classUtil_1_1MemoryOArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1Serializable.html">Util::Serializable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for serializable objects.  <a href="classUtil_1_1Serializable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1TextFileIArchive.html">Util::TextFileIArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading archive for text istream.  <a href="classUtil_1_1TextFileIArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1TextFileOArchive.html">Util::TextFileOArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving archive for character based ostream.  <a href="classUtil_1_1TextFileOArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1XdrFileIArchive.html">Util::XdrFileIArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading / input archive for binary XDR file.  <a href="classUtil_1_1XdrFileIArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1XdrFileOArchive.html">Util::XdrFileOArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving / output archive for binary XDR file.  <a href="classUtil_1_1XdrFileOArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3425912b370d34372bdd6939becb208f"><td class="memTemplParams" colspan="2">template&lt;class Archive , typename T &gt; </td></tr>
<tr class="memitem:ga3425912b370d34372bdd6939becb208f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Serialize__Module.html#ga3425912b370d34372bdd6939becb208f">Util::serialize</a> (Archive &amp;ar, T &amp;data, const unsigned int version)</td></tr>
<tr class="memdesc:ga3425912b370d34372bdd6939becb208f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize one object of type T.  <a href="group__Serialize__Module.html#ga3425912b370d34372bdd6939becb208f">More...</a><br /></td></tr>
<tr class="separator:ga3425912b370d34372bdd6939becb208f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga965cecf6693616b058003471cbd786de"><td class="memTemplParams" colspan="2">template&lt;class Archive , typename T &gt; </td></tr>
<tr class="memitem:ga965cecf6693616b058003471cbd786de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Serialize__Module.html#ga965cecf6693616b058003471cbd786de">Util::serializeEnum</a> (Archive &amp;ar, T &amp;data, const unsigned int version=0)</td></tr>
<tr class="memdesc:ga965cecf6693616b058003471cbd786de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an enumeration value.  <a href="group__Serialize__Module.html#ga965cecf6693616b058003471cbd786de">More...</a><br /></td></tr>
<tr class="separator:ga965cecf6693616b058003471cbd786de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebec7331d2435226c0ca11acef0788bf"><td class="memTemplParams" colspan="2">template&lt;class Archive , typename T &gt; </td></tr>
<tr class="memitem:gaebec7331d2435226c0ca11acef0788bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Serialize__Module.html#gaebec7331d2435226c0ca11acef0788bf">Util::serializeCheck</a> (Archive &amp;ar, T &amp;data, const char *label=&quot;&quot;)</td></tr>
<tr class="memdesc:gaebec7331d2435226c0ca11acef0788bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a value, or save and check correctness on loading.  <a href="group__Serialize__Module.html#gaebec7331d2435226c0ca11acef0788bf">More...</a><br /></td></tr>
<tr class="separator:gaebec7331d2435226c0ca11acef0788bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Serialization of C++ objects to/from file or memory.</p>
<p>The code in this module provides a system for serializing sequences of C++ objects to a file or to random access memory. A serialization of an object stores the full internal state and allows the object to be reconstructed. The design is loosely based on that of the Boost serialization library, <a href="http://www.boost.org/doc/libs/1_48_0/libs/serialization/doc/index.html">http://www.boost.org/doc/libs/1_48_0/libs/serialization/doc/index.html</a> but is much simpler (and less powerful) than the Boost library.</p>
<h1><a class="anchor" id="Archives"></a>
Archives</h1>
<p>An archive stores serialized data, either in a file or in RAM. The definition of an archive used here is very similar to that used in the Boost serialization library. An archive class may model either a saving / output archive, to which data is saved, or a loading / input archive, from which data is loaded. By convention, the names of saving/output archive classes end with the string OArchive and the names of loading/input archive classes end with the string IArchive.</p>
<p>Different archive classes store serialized objects in different forms. For example, <a class="el" href="classUtil_1_1TextFileOArchive.html" title="Saving archive for character based ostream.">TextFileOArchive</a> and <a class="el" href="classUtil_1_1TextFileIArchive.html" title="Loading archive for text istream.">TextFileIArchive</a> are saving and loading archive classes, respectively, that are wrappers for ofstream or ifstream file stream objects in which data is stored in a character representation. <a class="el" href="classUtil_1_1BinaryFileOArchive.html" title="Saving / output archive for binary ostream.">BinaryFileOArchive</a> and <a class="el" href="classUtil_1_1BinaryFileIArchive.html" title="Saving archive for binary istream.">BinaryFileIArchive</a> are saving/output and loading / input archives that store data in a binary format. <a class="el" href="classUtil_1_1MemoryOArchive.html" title="Save archive for packed heterogeneous binary data.">MemoryOArchive</a> and <a class="el" href="classUtil_1_1MemoryIArchive.html" title="Input archive for packed heterogeneous binary data.">MemoryIArchive</a> are saving and loading archives that stored data in binary form in a block of random-access memory.</p>
<h1><a class="anchor" id="Operators"></a>
Overloaded IO operators</h1>
<p>Objects may be saved to a saving archive or loaded from a loading archive using overloaded operators, using the same syntax as that of the Boost library. Each saving archive class must define method templates that overload the &lt;&lt; (insertion) and &amp; operators. These overloaded operators must be equivalent, and must save an object to the archive. If ar is an instance of a saving archive, such as <a class="el" href="classUtil_1_1BinaryFileOArchive.html" title="Saving / output archive for binary ostream.">BinaryFileOArchive</a>, the expressions </p><div class="fragment"><div class="line">ar &lt;&lt; data; </div>
<div class="line">ar &amp;  data;</div>
</div><!-- fragment --><p> are thus equivalent, and both save the state of variable data into archive ar. Each loading archive class must instead define template methods to overload the &gt;&gt; (extractor) and &amp; operator, which must be equivalent, and which must load an object from the archive. If ar is an instance of a loading archive, such as <a class="el" href="classUtil_1_1BinaryFileIArchive.html" title="Saving archive for binary istream.">BinaryFileIArchive</a>, then the expressions </p><div class="fragment"><div class="line">ar &gt;&gt; data;</div>
<div class="line">ar &amp;  data;</div>
</div><!-- fragment --><p> are equivalent, and both load the state of variable data from archive ar.</p>
<h1><a class="anchor" id="Serialize"></a>
Serialize Functions</h1>
<p>Objects of type T can be saved to or loaded from an instance of a class Archive if and only if the compiler can find a function named serialize with the signature </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> serialize(Archive&amp; ar, T&amp; data, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> version)</div>
</div><!-- fragment --><p> Here, "version" is an integer index that indicates the version of the archive. This version id is normally given by an integer member of the archive class. The operator &amp; for a class Archive is normally implemented by a method template </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> Archive::operator &amp; (T&amp; data);</div>
<div class="line">{  serialize(*<span class="keyword">this</span>, data, version_); }</div>
</div><!-- fragment --><p> that simply calls the appropiate serialize method. Here, version_ is an integer member of the Archive class that stores the archive version id. Similar templates must be provided for the &lt;&lt; or &gt;&gt; operator.</p>
<p>Each archive class provides serialize functions for all of the built-in C/C++ types, as well as few other common data types such as std::string. Definitions of the serialize function for saving archive types must save (write) data, and those for loading archive types must load (read) data.</p>
<p>Instances of user-defined classes may also be serialized if an appropriate serialize function can be found by the compiler. Serialization of instances of a class T may be enabled by defining either:</p>
<ul>
<li>A global serialize function template, with a signature <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> serialize(Archive&amp; ar, T&amp; data, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> version);</div>
</div><!-- fragment --></li>
<li>A serialize method template in class T, with a signature <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="group__Serialize__Module.html#ga3425912b370d34372bdd6939becb208f">T::serialize</a>(Archive&amp; ar, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> version);</div>
</div><!-- fragment --> Note that, in either case, the archive type is normally a template parameter, so that the same serialize function can work with multiple types of archives.</li>
</ul>
<p>In order to use this system, it is worth understanding how the compiler finds an appropriate serialize method. When the C++ compiler needs a serialize method for a particular archive type Archive and data type T, it will look first for a function <a class="el" href="group__Serialize__Module.html#ga3425912b370d34372bdd6939becb208f" title="Serialize one object of type T.">serialize(Archive&amp;, T&amp;, unsigned int)</a> with exactly the required signature, and then for an appropriate template. Such functions are provided for each archive classes for all of the built-in C/C++ types, and are always used to serialize such types. For class types, their is normally no such non-template function, and so the compiler will look for an appropriate template, giving priority to templates in which fewer of the function parameters have types given by template arguments, rather than explicit types. If the compiler has access to a global serialize function template for class T with the signature described above, in which the archive type is a template parameter but the data type T is explicit, it will use this. If no such global serialize function template is found, the compiler will try to compile the following generic template, </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive, <span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> serialize(Archive&amp; ar, T&amp; data, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> version)</div>
<div class="line">{  data.serialize(ar, version); }</div>
</div><!-- fragment --><p> which is defined in the file src/util/serialize.h. This template simply calls the serialize method of class T, and so will not compile if no such method exists. The compiler can thus use, in decreasing order of priority: 1) An explicit serialize function for type T and a specific archive type, 2) A serialize function template for a specific type T in which the archive type is a template parameter, or 3) A serialize method of class T in which the archive type is a template parameter. If none of these are accessible for class T, compilation will fail for any code that attempts to serialize an instance of class T.</p>
<p>The use of a single operator &amp; to represent both output (when applied to a saving archive) and input (when applied to a loading archive), makes it possible to write a single serialize function template for each class that specifies how to order save or load instances of that class, by specifying the order in which members of the class are serialized. For example, consider the following definition of a simple complex number class: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Complex  {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">   A(<span class="keywordtype">double</span> real, <span class="keywordtype">double</span> imag) : real_(real), imag_(imag) {}</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line">   <span class="keywordtype">void</span> serialize(Archive&amp; ar, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> version)</div>
<div class="line">   { </div>
<div class="line">      ar &amp; real_;</div>
<div class="line">      ar &amp; imag_:</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> </div>
<div class="line">   <span class="keywordtype">double</span> real_;</div>
<div class="line">   <span class="keywordtype">double</span> imag_;   </div>
<div class="line"> </div>
<div class="line">} </div>
</div><!-- fragment --><p> The serialize method template provides instructions for the order in which to either save the two floating point members of the class to a saving archive, or to load them from a loading archive. The use of a template in which the archive type is a parameter allows a single serialize method to be used with any type of saving or loading archive.</p>
<p>The most serious disadvantage of this system is that, if the serialize method is defined by a template, it cannot also be a virtual method. As a result, the serialize method template for a class cannot be accessed polymorphically, via a pointer or reference to a base class. This limitation becomes a problem in designs in which some objects are accessed only via base class pointers. The <a class="el" href="classUtil_1_1Serializable.html" title="Abstract class for serializable objects.">Serializable</a> abstract base class, discussed below, partially solves this problem, by replacing the serialize method template by a pair of virtual save() and load() methods.</p>
<h1><a class="anchor" id="Serializable"></a>
Serializable Classes</h1>
<p><a class="el" href="classUtil_1_1Serializable.html" title="Abstract class for serializable objects.">Serializable</a> is an abstract base class that provides an alternate interface for serializing objects, using virtual functions rather than method templates. Each subclass of <a class="el" href="classUtil_1_1Serializable.html" title="Abstract class for serializable objects.">Serializable</a> must define virtual save() and load() methods with the following signatures: </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> save(<a class="code" href="classUtil_1_1Serializable.html#aca43a1eea5ec5f13189a57892a7a6d04">Serializable::OArchive</a>&amp; ar);</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> load(<a class="code" href="classUtil_1_1Serializable.html#ac6bcbf9bac926cada5a398804410e891">Serializable::IArchive</a>&amp; ar);</div>
</div><!-- fragment --><p> The typenames <a class="el" href="classUtil_1_1Serializable.html#aca43a1eea5ec5f13189a57892a7a6d04" title="Type of output archive used by save method.">Serializable::OArchive</a> and <a class="el" href="classUtil_1_1Serializable.html#ac6bcbf9bac926cada5a398804410e891" title="Type of input archive used by load method.">Serializable::IArchive</a> are typedefs that define a pair of archive classes to be used for serialization.</p>
<p>The advantage of using virtual functions is that it allows these methods to be accessed polymorphically, via base class pointers or references. The disadvantage is that it requires the hard-coding of a single type type of saving and loading archive. To retain some flexibility, these saving and loading types are defined in the <a class="el" href="classUtil_1_1Serializable.html" title="Abstract class for serializable objects.">Serializable</a> class by a pair of typedefs. This allows the type of archives used with <a class="el" href="classUtil_1_1Serializable.html" title="Abstract class for serializable objects.">Serializable</a> objects to be changed throughout the code by changing these two typedefs and recompiling.</p>
<p>In practice, a serialize method or function template should be defined for relatively simple, non-polymorphic classes, but polymorhpic classes that are normally accessed via base class pointers need to be derived from <a class="el" href="classUtil_1_1Serializable.html" title="Abstract class for serializable objects.">Serializable</a>, and must implement save and load methods. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3425912b370d34372bdd6939becb208f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3425912b370d34372bdd6939becb208f">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Util::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize one object of type T. </p>
<p>Default implementation calls serialize method of data object. Can be overridden by any explicit specialization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ar</td><td>archive object </td></tr>
    <tr><td class="paramname">data</td><td>object to be serialized </td></tr>
    <tr><td class="paramname">version</td><td>archive version id </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="serialize_8h_source.html#l00029">29</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemoryOArchive_8h_source.html#l00224">Util::MemoryOArchive::operator&amp;()</a>, and <a class="el" href="MemoryOArchive_8h_source.html#l00231">Util::MemoryOArchive::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="ga965cecf6693616b058003471cbd786de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga965cecf6693616b058003471cbd786de">&#9670;&nbsp;</a></span>serializeEnum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Util::serializeEnum </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize an enumeration value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ar</td><td>archive object </td></tr>
    <tr><td class="paramname">data</td><td>object to be serialized </td></tr>
    <tr><td class="paramname">version</td><td>archive version id </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="serialize_8h_source.html#l00042">42</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Species_8h_source.html#l00127">Pscf::serialize()</a>.</p>

</div>
</div>
<a id="gaebec7331d2435226c0ca11acef0788bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebec7331d2435226c0ca11acef0788bf">&#9670;&nbsp;</a></span>serializeCheck()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Util::serializeCheck </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save a value, or save and check correctness on loading. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ar</td><td>archive object </td></tr>
    <tr><td class="paramname">data</td><td>object to be serialized </td></tr>
    <tr><td class="paramname">label</td><td>label C-string for object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="serialize_8h_source.html#l00064">64</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p class="reference">References <a class="el" href="global_8h_source.html#l00051">UTIL_THROW</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="aclassUtil_1_1Serializable_html_ac6bcbf9bac926cada5a398804410e891"><div class="ttname"><a href="classUtil_1_1Serializable.html#ac6bcbf9bac926cada5a398804410e891">Util::Serializable::IArchive</a></div><div class="ttdeci">BinaryFileIArchive IArchive</div><div class="ttdoc">Type of input archive used by load method.</div><div class="ttdef"><b>Definition:</b> <a href="Serializable_8h_source.html#l00047">Serializable.h:47</a></div></div>
<div class="ttc" id="aclassUtil_1_1Serializable_html_aca43a1eea5ec5f13189a57892a7a6d04"><div class="ttname"><a href="classUtil_1_1Serializable.html#aca43a1eea5ec5f13189a57892a7a6d04">Util::Serializable::OArchive</a></div><div class="ttdeci">BinaryFileOArchive OArchive</div><div class="ttdoc">Type of output archive used by save method.</div><div class="ttdef"><b>Definition:</b> <a href="Serializable_8h_source.html#l00042">Serializable.h:42</a></div></div>
<div class="ttc" id="agroup__Serialize__Module_html_ga3425912b370d34372bdd6939becb208f"><div class="ttname"><a href="group__Serialize__Module.html#ga3425912b370d34372bdd6939becb208f">Util::serialize</a></div><div class="ttdeci">void serialize(Archive &amp;ar, T &amp;data, const unsigned int version)</div><div class="ttdoc">Serialize one object of type T.</div><div class="ttdef"><b>Definition:</b> <a href="serialize_8h_source.html#l00029">serialize.h:29</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 6 2024 21:57:45 for PSCF+ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
