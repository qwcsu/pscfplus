\hypertarget{group__Container__Module}{}\doxysubsection{Container Templates}
\label{group__Container__Module}\index{Container Templates@{Container Templates}}
\doxysubsubsection*{Modules}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{group__Array__Module}{Object Arrays}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classUtil_1_1Array}{Array}} containers that store objects by value, and related iterators. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__Pointer__Array__Module}{Pointer Arrays}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classUtil_1_1Array}{Array}} containers that store pointers to objects, and related iterators. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__Matrix__Module}{Matrix Containers}}
\begin{DoxyCompactList}\small\item\em Two-\/dimensional array containers that store by objects value. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__List__Module}{Linked List}}
\begin{DoxyCompactList}\small\item\em A simple linked list implementation and associated iterator. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__Iterator__Module}{Iterators}}
\begin{DoxyCompactList}\small\item\em Iterators for use with particular containers. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsubsection{Detailed Description}
Container and iterator class templates.

This module contains a set of simple container templates, some of which are similar to containers provided by the C++ standard library. Bounds checking of indices for all array containers can be turned on (for safety) or off (for speed) by defining or not defining the U\+T\+I\+L\+\_\+\+D\+E\+B\+UG preprocessor macro.\hypertarget{group__Container__Module_container_array_matrix_sec}{}\doxysubsubsection{Array and Matrix Containers}\label{group__Container__Module_container_array_matrix_sec}
Containers templates whose name contains the string \textquotesingle{}\mbox{\hyperlink{classUtil_1_1Array}{Array}}\textquotesingle{} are one dimensional array containers, much like C arrays. All such containers overload the subscript \mbox{[}\mbox{]} operator so as to return an object by reference, using the same syntax as a C array or a std\+::vector\+: If A is an array, then A\mbox{[}i\mbox{]} is a reference to the ith element of A.

Container templates whose name contains the string \textquotesingle{}\mbox{\hyperlink{classUtil_1_1Matrix}{Matrix}}\textquotesingle{} are two dimensional arrays. These overload the (int, int) operator to access elements\+: If M is a \mbox{\hyperlink{classUtil_1_1Matrix}{Matrix}}, then M(i, j) is a reference to the element in column j of row i of A.\hypertarget{group__Container__Module_container_prefix_sec}{}\doxysubsubsection{Container Name Prefixes}\label{group__Container__Module_container_prefix_sec}
The names of many containers have prefixes before the word \mbox{\hyperlink{classUtil_1_1Array}{Array}} or \mbox{\hyperlink{classUtil_1_1Matrix}{Matrix}} that indicates policies for memory allocation and management.

Containers templates whose name begins with the letter \textquotesingle{}D\textquotesingle{} (such as \mbox{\hyperlink{classUtil_1_1DArray}{D\+Array}}, \mbox{\hyperlink{classUtil_1_1DSArray}{D\+S\+Array}}, \mbox{\hyperlink{classUtil_1_1DPArray}{D\+P\+Array}}, and \mbox{\hyperlink{classUtil_1_1DMatrix}{D\+Matrix}}) use dynamically allocated memory. The declaration \char`\"{}\+D\+Array$<$int$>$ A\char`\"{} declares a dynamically allocated array of integers. \mbox{\hyperlink{classUtil_1_1Memory}{Memory}} must be explicitly allocated for these containers by calling the \char`\"{}allocate\char`\"{} method after the container is instantiated and before it is used. Dynamically allocated containers can only be allocated once and are not resizable. Attempting to allocate a container more than once is as an error, and causes an \mbox{\hyperlink{classUtil_1_1Exception}{Exception}} to be thrown.

Containers templates whose name begins with a letter \textquotesingle{}F\textquotesingle{} (such as \mbox{\hyperlink{classUtil_1_1FArray}{F\+Array}}, \mbox{\hyperlink{classUtil_1_1FSArray}{F\+S\+Array}}, \mbox{\hyperlink{classUtil_1_1FPArray}{F\+P\+Array}}, and \mbox{\hyperlink{classUtil_1_1FMatrix}{F\+Matrix}}) are fixed size containers. The capacity of each such container is determined at compile time by a template parameter or parameters. Thus, for example, 
\begin{DoxyCode}{0}
\DoxyCodeLine{FArray<int, 4> A;}
\end{DoxyCode}
 declares a fixed size array of four integers, much like the declaration \char`\"{}int V\mbox{[}4\mbox{]}\char`\"{} of a fixed size C array.

The letter \char`\"{}\+S\char`\"{} in the names of \mbox{\hyperlink{classUtil_1_1DSArray}{D\+S\+Array}} and \mbox{\hyperlink{classUtil_1_1FSArray}{F\+S\+Array}} indicate that these are \char`\"{}sized\char`\"{} arrays. These arrays have a variable logical size that is less than or equal to the physical capacity. The logical size is the current number of elements, which are always stored contiguously from index 0 to index size -\/ 1. Accessing an element with index greater than or equal to size is an error, and will cause an \mbox{\hyperlink{classUtil_1_1Exception}{Exception}} to be thrown if debugging is enabled. The capacity of an array is the number of elements for which memory has been allocated. The size of such an array is initially set to zero, and elements are added sequentially by the append() method, which adds a new element at the end of the array and increments the size counter. Once the size reaches the array capacity, attempting to append another element will cause an \mbox{\hyperlink{classUtil_1_1Exception}{Exception}} to be thrown.

\mbox{\hyperlink{classUtil_1_1Array}{Array}} containers whose name includes the prefix G are sized arrays with a capacity that can grow (G=\char`\"{}growable\char`\"{}) as needed as elements are appended. The \char`\"{}\+G\+Array\char`\"{} template thus implements a dynamic array very similiar to the standard library std\+::vector. Automatic resizing changes the address of the beginning of the array, and invalidates all iterators and pointers to elements.\hypertarget{group__Container__Module_container_pointer_sec}{}\doxysubsubsection{Pointer Arrays}\label{group__Container__Module_container_pointer_sec}
Container templates whose name contains the prefix \char`\"{}\+P\char`\"{} are pointer arrays. A pointer array is a container that stores pointers to objects that are instantiated outside of the array, rather than storing actual objects. The containers \mbox{\hyperlink{classUtil_1_1DPArray}{D\+P\+Array}} and \mbox{\hyperlink{classUtil_1_1FPArray}{F\+P\+Array}} are dynamically allocated fixed size pointer arrays, respectively. The \mbox{\hyperlink{classUtil_1_1GPArray}{G\+P\+Array}} array is a growable pointer array, which can grow without bound. The pointer arrays are all similar to \char`\"{}sized\char`\"{} arrays in that they have a logical size that must be less than or equal to their capacity, and in that elements must can be added to the end of an initially empty array by function \char`\"{}append(\+T\& )\char`\"{}. Pointer arrays use the same interface for the subscript operator (which returns a reference) and the append function (which takes a reference parameter) as that used by the sized and object arrays. A pointer array of type D\+P\+Array$<$ T $>$ is thus different from a sized array of pointers, of type D\+S\+Array$<$\+T$\ast$$>$, because D\+P\+Array$<$ T $>$ overloads the \mbox{[}\mbox{]} operator to return a reference to an object of type T that is referenced by a private pointer, whereas the subscript operator for a D\+S\+Array$<$\+T$\ast$$>$ returns an actual pointer. 